#include "ShaderWriter.hpp"

#include "aderite/Aderite.hpp"
#include "aderite/utility/Log.hpp"
#include "aderite/utility/Random.hpp"
#include "aderite/asset/AssetManager.hpp"

ADERITE_EDITOR_COMPILER_NAMESPACE_BEGIN

constexpr int c_VariableLength = 16;
#define NEW_VARIABLE std::string("v") + aderite::utility::generateString(c_VariableLength)

ShaderWriter::ShaderWriter(ShaderType type, const std::string& name)
	: m_type(type), m_name(name)
{
	m_functions.push_back(createMainScope());
	m_currentScope = &m_functions[0];
	m_mainScope = &m_functions[0];
}

Variable ShaderWriter::getProperty(const std::string& prop) const {
	return "u_" + m_name + "_" + prop;
}

Variable ShaderWriter::add2DSamplingInstruction(const Variable& texture) {
	std::string result = NEW_VARIABLE;
	m_currentScope->Body << "\tvec4 " << result << " = texture2D(" << texture << ", v_texcoord);\n";
	return result;
}

Variable ShaderWriter::addAddInstruction(const std::string& type, const Variable& lhs, const Variable& rhs) {
	std::string result = NEW_VARIABLE;
	m_currentScope->Body << "\t" << type << " " << result << " = " << lhs << " + " << rhs << ";\n";
	return result;
}

void ShaderWriter::addFragmentColorInstruction(const Variable& value) {
	if (m_currentScope != m_mainScope) {
		LOG_ERROR("addFragmentColorInstruction can only be called in the main scope");
		return;
	}
	m_currentScope->Body << "\tgl_FragColor = " << value << ";\n";
}

void ShaderWriter::writeToFile() {
	std::filesystem::path outPath = ::aderite::Engine::getAssetManager()->getRawDir() / (getPrefix() + m_name + ".sc");
	std::stringstream output;
	std::ofstream outFile(outPath);
	LOG_TRACE("Outputting to file {0}", outPath.string());

	// Content
	writeInputsOutputs(outFile);
	writeGenerationComment(outFile);
	writeLibraries(outFile);
	writeConstants(outFile);
	writeFunctions(outFile);
}

ShaderWriter::ShaderType ShaderWriter::getType() const {
	return m_type;
}

void ShaderWriter::writeInputsOutputs(std::ofstream& of) {
	// Inputs, outputs
	of << "$input v_normal, v_texcoord\n\n";
}

void ShaderWriter::writeGenerationComment(std::ofstream& of) {
	// Header comment
	auto t = std::time(nullptr);
	auto tm = *std::localtime(&t);

	of << "/*\n";
	of << " *" << " DON'T CHANGE DIRECTLY" << "\n";
	of << " *" << " This is a " << getFullName() << " shader header file generated by aderite for material " << m_name << "\n";
	of << " *" << " Generated at " << std::put_time(&tm, "%Y-%m-%d %H.%M.%S") << "\n";
	of << " */" << "\n\n";
}

void ShaderWriter::writeLibraries(std::ofstream& of) {
	of << "// Libraries\n";
	of << "#include \"bgfx_shader.sh\"\n";
	of << "#include \"shaderLib.sh\"\n";
	of << "#include \"" << m_name << ".sh\"\n";
	of << "\n";
}

void ShaderWriter::writeConstants(std::ofstream& of) {
	of << "// Constants\n";
	of << "\n";
}

void ShaderWriter::writeFunctions(std::ofstream& of) {
	of << "// Functions\n";

	for (Function& f : m_functions) {
		writeScope(of, &f);
	}
}

void ShaderWriter::writeScope(std::ofstream& of, Function* scope) {
	of << scope->ReturnType << " " << scope->Name << "(" << scope->Arguments << ") {\n";
	of << scope->Body.str();
	of << "}\n";
}

const char* ShaderWriter::getPrefix() const {
	switch (m_type) {
	case ShaderType::FRAGMENT: {
		return "fs_";
	}
	case ShaderType::VERTEX: {
		return "vs_";
	}
	default: {
		return "";
	}
	}
}

const char* ShaderWriter::getFullName() const {
	switch (m_type) {
	case ShaderType::FRAGMENT: {
		return "fragment";
	}
	case ShaderType::VERTEX: {
		return "vertex";
	}
	default: {
		return "";
	}
	}
}

ShaderWriter::Function ShaderWriter::createMainScope() const {
	return Function{
		"void",
		"main",
		"",
	};
}

ADERITE_EDITOR_COMPILER_NAMESPACE_END
