#include "MaterialType.hpp"

#include <sstream>
#include <iomanip>
#include <ctime>
#include <fstream>

#include "aderite/Aderite.hpp"
#include "aderite/utility/Log.hpp"
#include "aderite/asset/AssetManager.hpp"

ADERITE_EDITOR_COMPILER_NAMESPACE_BEGIN

void compileMaterialType(asset::MaterialTypeAsset* type) {
	std::filesystem::path outPath = ::aderite::Engine::getAssetManager()->getRawDir() / (type->getName() + ".sh");
	std::stringstream output;
	std::ofstream outFile(outPath);
	LOG_TRACE("Generating material header for {0}", type->getName());

	// Recalculate offsets
	type->recalculate();

	// Header comment
	auto t = std::time(nullptr);
	auto tm = *std::localtime(&t);

	output << "/*\n";
	output << " *" << " DON'T CHANGE DIRECTLY" << "\n";
	output << " *" << " This is a shader header file generated by aderite for material " << type->getName() << "\n";
	output << " *" << " Generated at " << std::put_time(&tm, "%Y-%m-%d %H.%M.%S") << "\n";
	output << " */" << "\n\n";

	// Uniform buffer
	unsigned int arraySize = 0;

	if (type->getFields().ElementCount % 4 != 0) {
		arraySize = ((type->getFields().ElementCount - type->getFields().ElementCount % 4) / 4) + 1;
	}
	else {
		arraySize = type->getFields().ElementCount / 4;
	}

	output << "uniform vec4 u_mat_buffer_" << type->getName() << "[" << arraySize << "]\n";

	// Properties
	output << "\n" << "// Properties\n";
	// Should be packed already by recalculate call
	std::string samplers = "";
	unsigned int samplerIdx = 0;
	for (asset::prop::Property* prop : type->getFields().Properties) {
		// Need to generate in a packed manner therefor
		// Recalculate method prioritizes this structure:
		// vec4
		// vec3 float
		// vec2 vec2
		// vec2 float float
		// float float float float

		unsigned int arrayRemainderIdx = prop->getOffset() % 4; // This is the current element
		unsigned int arrayIdx = (prop->getOffset() - arrayRemainderIdx) / 4;
		uint8_t elementCount = asset::prop::getElementCountForType(prop->getType());
		std::string access = "";

		switch (elementCount) {
		case 4: {
			// vec4 will always be first so no need to check for packing
			access = "xyzw";
			break;
		}
		case 3: {
			// vec3 will always be first so xyz
			access = "xyz";
			break;
		}
		case 2: {
			// vec2 can be first or second
			if (arrayRemainderIdx == 0) {
				// first
				access = "xy";
			}
			else {
				// second
				access = "zw";
			}
			break;
		}
		case 1: {
			// Check
			switch (arrayRemainderIdx) {
			case 0: {
				access = "x";
				break;
			}
			case 1: {
				access = "y";
				break;
			}
			case 2: {
				access = "z";
				break;
			}
			case 3: {
				access = "w";
				break;
			}
			default: {
				LOG_ERROR("Incorrect format, remainder {0}", arrayRemainderIdx);
			}
			}
			break;
		}
		}

		switch (prop->getType()) {
		case asset::prop::PropertyType::FLOAT:
		case asset::prop::PropertyType::VEC2:
		case asset::prop::PropertyType::VEC3:
		case asset::prop::PropertyType::VEC4: {
			output << "#define u_" 
				<< type->getName() << "_" << prop->getName() 
				<< " u_mat_buffer_" << type->getName() 
				<< "[" << arrayIdx << "]." << access << "\n";
			break;
		}
		case asset::prop::PropertyType::TEXTURE_2D: {
			samplers += "SAMPLER2D(s_mat_" + type->getName() + "_" + prop->getName() + ", " + std::to_string(samplerIdx++) + ");\n";
			break;
		}
		case asset::prop::PropertyType::TEXTURE_CUBE: {
			samplers += "SAMPLERCUBE(s_mat_" + type->getName() + "_" + prop->getName() + ", " + std::to_string(samplerIdx++) + ");\n";
			break;
		}
		default:
			LOG_WARN("Unknown property type when generating header");
		}
	}

	// Samplers
	output << "\n" << "// Samplers\n";
	output << samplers << "\n";

	// Output to file
	LOG_TRACE("Writing shader header to file {0}", outPath.string().c_str());
	outFile << output.str();
}

ADERITE_EDITOR_COMPILER_NAMESPACE_END
