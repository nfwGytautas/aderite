#include "ShaderEvaluator.hpp"

#include "aderite/Aderite.hpp"
#include "aderite/utility/Log.hpp"
#include "aderite/utility/Random.hpp"
#include "aderiteeditor/asset/property/Property.hpp"

ADERITE_EDITOR_COMPILER_NAMESPACE_BEGIN

constexpr int c_VariableLength = 16;

ShaderEvaluator::ShaderEvaluator(ShaderType type, asset::MaterialTypeAsset* material)
	: m_type(type), m_material(material)
{
	m_functions.push_back(createMainScope());
	m_currentScope = &m_functions[0];
	m_mainScope = &m_functions[0];
}

EvaluatorValue ShaderEvaluator::getProperty(const asset::Property* prop) {
	return createValue("u_" + std::to_string(m_material->getHandle()) + "_" + prop->getName());
}

EvaluatorValue ShaderEvaluator::getSampler(const asset::Sampler* samp) {
	return createValue("u_" + std::to_string(m_material->getHandle()) + "_" + samp->getName());
}

EvaluatorValue ShaderEvaluator::add2DSamplingInstruction(const EvaluatorValue& texture) {
	EvaluatorValue value = createValue();
	m_currentScope->Body << "\tvec4 " << getValue(value) << " = texture2D(" << getValue(texture) << ", v_texcoord);\n";
	return value;
}

EvaluatorValue ShaderEvaluator::addAddInstruction(const std::string& type, const EvaluatorValue& lhs, const EvaluatorValue& rhs) {
	EvaluatorValue result = createValue();
	m_currentScope->Body << "\t" << type << " " << getValue(result) << " = " << getValue(lhs) << " + " << getValue(rhs) << ";\n";
	return result;
}

void ShaderEvaluator::addFragmentColorInstruction(const EvaluatorValue& value) {
	if (m_currentScope != m_mainScope) {
		LOG_ERROR("addFragmentColorInstruction can only be called in the main scope");
		return;
	}
	m_currentScope->Body << "\tgl_FragColor = " << getValue(value) << ";\n";
}

void ShaderEvaluator::write(std::ostream& stream) {	
	// Content
	writeInputsOutputs(stream);
	writeGenerationComment(stream);
	writeLibraries(stream);
	writeConstants(stream);
	writeFunctions(stream);
}

ShaderEvaluator::ShaderType ShaderEvaluator::getType() const {
	return m_type;
}

void ShaderEvaluator::writeInputsOutputs(std::ostream& of) {
	// Inputs, outputs
	of << "$input v_normal, v_texcoord\n\n";
}

void ShaderEvaluator::writeGenerationComment(std::ostream& of) {
	// Header comment
	auto t = std::time(nullptr);
	auto tm = *std::localtime(&t);

	of << "/*\n";
	of << " *" << " DON'T CHANGE DIRECTLY" << "\n";
	of << " *" << " This is a " << getFullName() << " shader header file generated by aderite for material " << m_material->getHandle() << "\n";
	of << " *" << " Generated at " << std::put_time(&tm, "%Y-%m-%d %H.%M.%S") << "\n";
	of << " */" << "\n\n";
}

void ShaderEvaluator::writeLibraries(std::ostream& of) {
	of << "// Libraries\n";
	of << "#include \"bgfx_shader.sh\"\n";
	of << "#include \"shaderLib.sh\"\n";
	of << "#include \"material_" << m_material->getHandle() << ".sh\"\n";
	of << "\n";
}

void ShaderEvaluator::writeConstants(std::ostream& of) {
	of << "// Constants\n";
	of << "\n";
}

void ShaderEvaluator::writeFunctions(std::ostream& of) {
	of << "// Functions\n";

	for (Function& f : m_functions) {
		writeScope(of, &f);
	}
}

void ShaderEvaluator::writeScope(std::ostream& of, Function* scope) {
	of << scope->ReturnType << " " << scope->Name << "(" << scope->Arguments << ") {\n";
	of << scope->Body.str();
	of << "}\n";
}

const char* ShaderEvaluator::getPrefix() const {
	switch (m_type) {
	case ShaderType::FRAGMENT: {
		return ".fs";
	}
	case ShaderType::VERTEX: {
		return ".vs";
	}
	default: {
		return "";
	}
	}
}

const char* ShaderEvaluator::getFullName() const {
	switch (m_type) {
	case ShaderType::FRAGMENT: {
		return "fragment";
	}
	case ShaderType::VERTEX: {
		return "vertex";
	}
	default: {
		return "";
	}
	}
}

ShaderEvaluator::Function ShaderEvaluator::createMainScope() const {
	return Function{
		"void",
		"main",
		"",
	};
}

std::string ShaderEvaluator::getValue(EvaluatorValue value) const {
	return m_values[value];
}

EvaluatorValue ShaderEvaluator::createValue() {
	std::string value = std::string("v") + aderite::utility::generateString(c_VariableLength);
	m_values.push_back(value);
	return m_values.size() - 1;
}

EvaluatorValue ShaderEvaluator::createValue(const std::string& value) {
	m_values.push_back(value);
	return m_values.size() - 1;
}

ADERITE_EDITOR_COMPILER_NAMESPACE_END
