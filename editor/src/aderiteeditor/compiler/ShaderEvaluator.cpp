#include "ShaderEvaluator.hpp"
#include <iomanip>

#include "aderite/Aderite.hpp"
#include "aderite/utility/Log.hpp"
#include "aderite/utility/Random.hpp"

#include "aderiteeditor/asset/property/Property.hpp"

namespace aderite {
namespace compiler {

static constexpr const char* c_PropToShader[] = {"UNKNOWN", "float", "vec2", "vec3", "vec4", "BgfxSampler2D", "BgfxSamplerCube"};

constexpr int c_VariableLength = 16;

ShaderEvaluator::ShaderEvaluator(ShaderType type, asset::MaterialTypeAsset* material) : m_type(type), m_material(material) {
    m_functions.push_back(createMainScope());
    m_currentScope = &m_functions[0];
    m_mainScope = &m_functions[0];
}

void ShaderEvaluator::addComment(const std::string& comment) {
    m_currentScope->Body << "\t// " << comment << "\n";
}

void ShaderEvaluator::getMaterialField(const std::string& field, const std::string& storeIn, const std::string& type) {
    m_currentScope->Body << "\t" << type << " " << storeIn << " = "
                         << "mf_" << field << ";\n";
}

void ShaderEvaluator::getProperty(const asset::Property* prop, const std::string& storeIn) {
    m_currentScope->Body << "\t" << c_PropToShader[static_cast<size_t>(prop->getType())] << " " << storeIn << " = "
                         << "u_ " << std::to_string(m_material->getHandle()) << "_" << prop->getName() << ";\n";
}

void ShaderEvaluator::getAttribute(const std::string& attr, const std::string& storeIn, const std::string& type) {
    m_currentScope->Body << "\t" << type << " " << storeIn << " = " << attr << ";\n";
}

void ShaderEvaluator::getSampler(const asset::Sampler* samp, const std::string& storeIn) {
    m_currentScope->Body << "\t" << c_PropToShader[static_cast<size_t>(samp->getType())] << " " << storeIn << " = "
                         << "u_ " << std::to_string(m_material->getHandle()) << "_" << samp->getName() << ";\n";
}

void ShaderEvaluator::add2DSamplingInstruction(const std::string& texture, const std::string& uv, const std::string& storeIn) {
    m_currentScope->Body << "\tvec4 " << storeIn << " = texture2D(" << texture << ", " << uv << ");\n";
}

void ShaderEvaluator::addAddInstruction(const std::string& type, const std::string& lhs, const std::string& rhs,
                                        const std::string& storeIn) {
    m_currentScope->Body << "\t" << type << " " << storeIn << " = " << lhs << " + " << rhs << ";\n";
}

void ShaderEvaluator::addFragmentColorInstruction(const std::string& value) {
    if (m_currentScope != m_mainScope) {
        LOG_ERROR("addFragmentColorInstruction can only be called in the main scope");
        return;
    }
    m_currentScope->Body << "\tgl_FragColor = " << value << ";\n";
}

void ShaderEvaluator::write(std::ostream& stream) {
    // Content
    writeInputsOutputs(stream);
    writeGenerationComment(stream);
    writeLibraries(stream);
    writeConstants(stream);
    writeFunctions(stream);
}

ShaderEvaluator::ShaderType ShaderEvaluator::getType() const {
    return m_type;
}

void ShaderEvaluator::writeInputsOutputs(std::ostream& of) {
    // Inputs, outputs
    of << "$input v_normal, v_texcoord\n\n";
}

void ShaderEvaluator::writeGenerationComment(std::ostream& of) {
    // Header comment
    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);

    of << "/*\n";
    of << " *"
       << " DON'T CHANGE DIRECTLY"
       << "\n";
    of << " *"
       << " This is a " << getFullName() << " shader header file generated by aderite for material " << m_material->getName() << "\n";
    of << " *"
       << " Generated at " << std::put_time(&tm, "%Y-%m-%d %H.%M.%S") << "\n";
    of << " */"
       << "\n\n";
}

void ShaderEvaluator::writeLibraries(std::ostream& of) {
    of << "// Libraries\n";
    of << "#include \"bgfx_shader.sh\"\n";
    of << "#include \"shaderLib.sh\"\n";
    of << "#include \"material_" << m_material->getHandle() << ".sh\"\n";
    of << "\n";
}

void ShaderEvaluator::writeConstants(std::ostream& of) {
    of << "// Constants\n";
    of << "\n";
}

void ShaderEvaluator::writeFunctions(std::ostream& of) {
    of << "// Functions\n";

    for (Function& f : m_functions) {
        writeScope(of, &f);
    }
}

void ShaderEvaluator::writeScope(std::ostream& of, Function* scope) {
    of << scope->ReturnType << " " << scope->Name << "(" << scope->Arguments << ") {\n";
    of << scope->Body.str();
    of << "}\n";
}

const char* ShaderEvaluator::getPrefix() const {
    switch (m_type) {
    case ShaderType::FRAGMENT: {
        return ".fs";
    }
    case ShaderType::VERTEX: {
        return ".vs";
    }
    default: {
        return "";
    }
    }
}

const char* ShaderEvaluator::getFullName() const {
    switch (m_type) {
    case ShaderType::FRAGMENT: {
        return "fragment";
    }
    case ShaderType::VERTEX: {
        return "vertex";
    }
    default: {
        return "";
    }
    }
}

ShaderEvaluator::Function ShaderEvaluator::createMainScope() const {
    return Function {
        "void",
        "main",
        "",
    };
}

} // namespace compiler
} // namespace aderite
